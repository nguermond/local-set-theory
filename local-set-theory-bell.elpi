%% local set theory following Bell's book, where
%% 'eq' and 'star' are primitive,
%% but without 'forall', and 'imp'.

mem X XS :- std.mem XS X.


kind tm type.
kind ty type.

type unit ty.
type omega ty.
type prod ty -> ty -> ty.
type power ty -> ty.

type star tm.
type compr ty -> (tm -> tm) -> tm.
type opair tm -> tm -> tm.
type proj1 tm -> tm.
type proj2 tm -> tm.
type eq tm -> tm -> tm.
type in tm -> tm -> tm.


type typeof tm -> ty -> prop.


typeof T A :- (var T), (declare_constraint (typeof T A) [T]).
typeof star unit.
typeof (compr A T) (power A) :- (pi x\ (typeof x A) => (typeof (T x) omega)).
typeof (opair S T) (prod A B) :- (typeof S A), (typeof T B).
typeof (proj1 U) A :- (typeof U (prod A _)).
typeof (proj2 U) B :- (typeof U (prod _ B)).
typeof (eq S T) omega :- (typeof S A), (typeof T A).
typeof (in S T) omega :- (typeof T (power A)), (typeof S A).

kind pf type.
type proof pf -> tm -> (list tm) -> prop.
type thm (list tm) -> tm -> (list tm) -> (list pf) -> prop.


%% Can we directly eliminate all universals in H and L?


% thm (hyps) (statement) (hilbert proof) (proof tree)
thm H P [] [R0] :- print "*****************************************",
				   print "***Proving:***" P H,
				   ((proof R0 P H); print "***Failure:***" P H, fail),
				   print "***Success:***" P " [by] " R0.

thm H P [Q|L] [R0|R] :- (thm H Q L R),!,
						print "***Proving:***" P H,
						(std.append [Q|L] H L1),
						((proof R0 P L1); print "***Failure:***" P L1, fail),
						print "***Success:***" P " [by] " R0.


subst T X TX :- (pi x\ (copy_tm x X) => (copy_tm (T x) TX)).

copy_tm X X.
copy_tm (proj1 U1) (proj1 U2) :- (copy_tm U1 U2).
copy_tm (proj2 U1) (proj2 U2) :- (copy_tm U1 U2).
copy_tm (opair S1 T1) (opair S2 T2) :- (copy_tm S1 S2), (copy_tm T1 T2).
copy_tm (eq S1 T1) (eq S2 T2) :- (copy_tm S1 S2), (copy_tm T1 T2).
copy_tm (in S1 T1) (in S2 T2) :- (copy_tm S1 S2), (copy_tm T1 T2).
copy_tm (compr A1 P1) (compr A2 P2) :- (copy_ty A1 A2),
									   (pi x\ (copy_tm (P1 x) (P2 x))).

copy_ty (prod A1 B1) (prod A2 B2) :- (copy_ty A1 A2), (copy_ty B1 B2).
copy_ty (power A1) (power A2) :- (copy_ty A1 A2).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%          Axioms
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

vproof R P L :- print "Attempting to prove:" P "from" L,
				proof R P L.


%% tautology
proof (tautology) P L :- %print "Trying tautology",
						 (mem P L), print "tautology" P.

%% unity
proof (unity) (eq X star) _ :- print "unity" X,
							   (typeof X unit).

%% equality
proof (equality S T PS) PT L :- (mem (eq S T) L),
								(mem PS L),
								subst P T PT,
								% WARNING: This may run forever
								% if no solution exists!
								(P S = PS),
								print "equality " S "==" T "," PS "|-" PT.


%% product beta 1
proof (prod_beta1 S) (eq (proj1 (opair S _)) S) _ :- print "beta1" S.


%% product beta 2
proof (prod_beta2 T) (eq (proj2 (opair _ T)) T) _ :- print "beta2" T.

%% product eta
proof (prod_eta U) (eq (opair (proj1 U) (proj2 U)) U) _ :- print "eta" U,
														   typeof U (prod _ _).


%% comprehension
proof (comprehension (compr A P)) (eq (in T (compr A P)) PT) _ :-
	(P T = PT),
	print "comprehension" (in T (compr A P)).

%% Extensionality
proof (extensionality S T R) (eq S T) L :-
	(pi x\ (proof R (equiv (in x S) (in x T)) L)),
	print "extensionality" S T.

%% This should be a theorem, now that implication is primitive!?
%% %% Equivalence
proof (equivalence P Q R1 R2) (equiv P Q) L :-
%	(mem (imp P Q) L),
%	(mem (imp Q P) L),
	(proof R1 Q [P|L]),
	(proof R2 P [Q|L]),
	print "equivalence" P Q.

%% Forall
%% This invalid example illustrates why we must
%% sometimes backtrack after eliminating universals
%%  (P X) |- P x
%% -------------------------- (forall-intro)  >> Not possible, since x is free in X!
%%  (P X) |- (forall x, P x)
%% ------------------------------------ (forall-elim)
%%  (forall x, P x) |- (forall x, P x)

%% Whereas the following is valid
%%  P X |- P x
%% ------------------------ (forall-elim)
%%  (forall x, P x) |- P x
%% ------------------------------------ (forall-intro)
%%  (forall x, P x) |- (forall x, P x)
%% because here x is not free in (forall x, P x)!

%% For this reason we place the introduction rules before the elimination rules.

proof (forall-intro R) (forall A P) L :- print "forall-intro" P,
										 (pi x\ print "Subgoal:" (P x),
										  (proof R (P x) L)).

proof (let-intro R) (let x\ [(Q x)|(L1 x)]) L2 :- print "let-intro" L2,
												  (pi x\ (thm L2 (Q x) (L1 x) R)).


proof (forall-elim R) PT L :- (mem (forall A P) L),
							  (sigma x\
							   (not (mem (P x) L);
								(P x = forall A P))),
							  (print "forall-elim >>" (P X) "|-" PT),
							  (proof R PT [(P X)|L]).

proof (let-elim R) PT L :- (mem (let x\ (L1 x)) L),
						   (print "let-elim >>" (L1 x) "|-" PT),
						   (proof R PT (L1 X)).


proof (suppose-intro R) (suppose P [Q|L1]) L2 :- print "suppose-intro",
												 (thm [P|L2] Q L1 R).

proof (imp-intro) (imp P Q) L :- (mem (suppose P L1) L),
								 (mem Q L1),
								 print "imp-intro".

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%    Extra definitions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
type equiv tm -> tm -> tm.
type tt tm.
type and tm -> tm -> tm.
type imp tm -> tm -> tm.
type forall ty -> (tm -> tm) -> tm.
type ff tm.
type neg tm -> tm.
type or tm -> tm -> tm.
type exists ty -> (tm -> tm) -> tm.

typeof (equiv P Q) omega :- (typeof P omega), (typeof Q omega).
typeof tt omega.
typeof (and P Q) omega :- (typeof P omega), (typeof Q omega).
typeof (imp P Q) omega :- (typeof P omega), (typeof Q omega).
typeof (forall A P) omega :- (pi x\ (typeof x A) => (typeof (P x) omega)).
typeof ff omega.
typeof (exists A P) omega :- (pi x\ (typeof x A) => (typeof (P x) omega)).
typeof (neg P) omega :- (typeof P omega).
typeof (or P Q) omega :- (typeof P omega), (typeof Q omega).

proof (equiv-def) (eq (equiv P Q) (eq P Q)) _.
proof (tt-def) (eq tt (eq star star)) _.
proof (and-def) (eq (and P Q) (eq (opair P Q) (opair tt tt))) _.
proof (imp-def) (eq (imp P Q) (equiv (and P Q) P)) _.
proof (forall-def) (eq (forall A P) (eq (compr A P) (compr A (_\ tt)))) _.
proof (ff-def) (eq ff (forall omega (x\ x))) _.
proof (neg-def) (eq (neg P) (imp P ff)) _.
proof (or-def) (eq (or P Q) (forall omega (r\ (imp (and (imp P r) (imp Q r)) r)))) _.
proof (exists-def) (eq (exists A P)
					(forall omega (r\ (imp (forall A (x\ (imp (P x) r))) r)))) _.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%    Natural Numbers
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% type nat ty.
%% type zero tm.
%% type succ tm -> tm.
%% type rec ty -> (tm -> tm) -> tm -> (tm -> tm).
%% type add tm -> tm -> tm.

%% typeof zero nat.
%% typeof (succ X) nat :- (typeof X nat).
%% typeof (rec A F Z X) A :- (pi x\ (typeof x A) => (typeof (F x) A)),
%% 						  (typeof Z A), (typeof X nat).

%% proof (rec-zero) (eq (rec A F Z zero) Z) _.
%% proof (rec-succ) (eq (rec A F Z (succ N)) (F (rec A F Z N))) _.

%% proof (ind) (forall nat P) L :- (proof _ (P zero) L),
%% 								(pi n\ (proof _ (P (succ n)) [(P n)|L])).

%% proof (add-def) (eq (add X Y) (rec nat (n\ (succ n)) X Y)) _.

%% pf_add_id_right R :-
%% 	(pi x\
%% 	 (thm [] (eq (add x zero) x)
%% 	  [(eq (rec nat (n\ succ n) x zero) x),
%% 	   (eq (add x zero) (rec nat (n\ succ n) x zero))]
%% 	  (R x))).
%% lemma (add-id-right) (eq (add X zero) X) _.

%% lemma (add-comm) (eq (add X Y) (add Y X)) _.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%       Theorems
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Only state a lemma is its proof is validated.
% If a theorem is of the form
%   Hyps |- Conc,
% the corresponding lemma should be of the form
%   lemma Name Conc Context :- sublist Hyps Context
proof Name Statement Context :- lemma Name Statement Context.


pf_eq_refl R :- (pi x\ (thm [] (eq x x)
						[(eq (proj1 (opair x x)) x)]
						(R x))).
lemma (eq_refl) (eq X X) _.

pf_eq_sym R :- (pi x y\ (thm [(eq x y)] (eq y x)
						 [(eq x x)]
						 (R x y))).
lemma (eq_sym) (eq X Y) L :- (mem (eq Y X) L).

pf_eq_trans R :-
	(pi x y z\ (thm [(eq x y), (eq y z)] (eq x z)
				[]
				(R x y z))).
lemma (eq_trans) (eq X Z) L :- (mem (eq X Y) L), (mem (eq Y Z) L).

%% Can we prove
%% pf_equiv_def R :-
%% 	(pi p q\
%% 	 (thm [] (eq (imp p q) (eq (and p q) p))
%% 	  [(imp (eq (and p q) p) (imp p q))]
%% 	  (R p q))).

%% pf_equiv_intro R :-
%% 	(pi p q\
%% 	 (thm [(imp p q), (imp q p)] (equiv p q)
%% 	  [(eq (equiv p q) (eq p q))]
%% 	  (R p q))).


pf_equiv_eq_equiv R :-
	(pi p q\
	 (thm [] (equiv (equiv p q) (eq p q))
	  [(eq (eq p q) (equiv p q)),
	   (eq (equiv p q) (eq p q))]
	  (R p q))).
lemma (equiv_eq_equiv) (equiv (equiv P Q) (eq P Q)) _.

pf_eq_implies_equiv R :-
	(pi p q\
	 (thm [(equiv p q)] (eq p q)
	  [(eq (equiv p q) (eq p q))]
	  (R p q))).
lemma (eq_implies_equiv) (eq P Q) L :- (mem (equiv P Q) L).

pf_equiv_implies_eq R :-
	(pi p q\
	 (thm [(eq p q)] (equiv p q)
	  [(eq (eq p q) (equiv p q)),
	   (eq (equiv p q) (eq p q))]
	  (R p q))).
lemma (equiv_implies_eq) (equiv P Q) L :- (mem (eq P Q) L).

pf_equiv_elim1 R :-
	(pi p q\
	 (thm [(equiv p q), p] q
	  [(eq p q)]
	  (R p q))).
lemma (equiv_elim1) Q L :- (mem (equiv P Q) L), (mem P L).

pf_equiv_elim2 R :-
	(pi p q\
	 (thm [(equiv p q), q] p
	  [(eq q p), (eq p q)]
	  (R p q))).
lemma (equiv_elim2) P L :- (mem (equiv P Q) L), (mem Q L).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Theorems from Bell
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 3.1 - Conjunction
pf_conjunction_3_1_1 R :-
	(pi x1 x2 y1 y2\
	 (thm [(eq x1 x2), (eq y1 y2)] (eq (opair x1 y1) (opair x2 y2))
	  [(eq (opair x1 y1) (opair x2 y1)),
	   (eq (opair x1 y1) (opair x1 y1))]
	  (R x1 x2 y1 y2))).
lemma (conjunction_3_1_1) (eq (opair X1 Y1) (opair X2 Y2)) L :-
	(mem (eq X1 X2) L), (mem (eq Y1 Y2) L).

pf_conjunction_3_1_2_i R :-
	(pi x1 x2 y1 y2\
	 (thm [(eq (opair x1 y1) (opair x2 y2))] (eq x1 x2)
	  [(eq (proj1 (opair x2 y2)) x2),
	   (eq x1 (proj1 (opair x2 y2))),
	   (eq (proj1 (opair x1 y1)) x1),
	   (eq (proj1 (opair x1 y1)) (proj1 (opair x2 y2))),
	   (eq (proj1 (opair x1 y1)) (proj1 (opair x1 y1)))]
	  (R x1 x2 y1 y2))).
lemma (conjunction_3_1_2_i) (eq X1 X2) L :-
	(mem (eq (opair X1 Y1) (opair X2 Y2)) L).

pf_conjunction_3_1_2_ii R :-
	(pi x1 x2 y1 y2\
	 (thm [(eq (opair x1 y1) (opair x2 y2))] (eq y1 y2)
	  [(eq (proj2 (opair x2 y2)) y2),
	   (eq y1 (proj2 (opair x2 y2))),
	   (eq (proj2 (opair x1 y1)) y1),
	   (eq (proj2 (opair x1 y1)) (proj2 (opair x2 y2))),
	   (eq (proj2 (opair x1 y1)) (proj2 (opair x1 y1)))]
	  (R x1 x2 y1 y2))).
lemma (conjunction_3_1_2_i) (eq Y1 Y2) L :-
	(mem (eq (opair X1 Y1) (opair X2 Y2)) L).

pf_conjunction_3_1_4 R :-
	(thm [] tt
	 [(eq (eq star star) tt),
	  (eq star star),
	  (eq tt (eq star star))]
	 R).
lemma (conjunction_3_1_4) tt _.

pf_conjunction_3_1_5_i R :-
	(pi p\
	 (thm [p] (eq p tt)
	  [(eq (equiv p tt) (eq p tt)),
	   (equiv p tt),
	   tt]
	  (R p))).
lemma (conjunction_3_1_5_i) (eq P tt) L :- (mem P L).

pf_conjunction_3_1_5_ii R :-
	(pi p\
	 (thm [(eq p tt)] p
	  [(eq tt p), tt]
	  (R p))).
lemma (conjunction_3_1_5_ii) P L :- (mem (eq P tt) L).

pf_conjunction_3_1_6 R :-
	(pi p q\
	 (thm [p, q] (and p q)
	  [(eq (opair p q) (opair tt tt)),
	   (eq p tt),
	   (eq q tt),
	   (eq (eq (opair p q) (opair tt tt)) (and p q)),
	   (eq (and p q) (eq (opair p q) (opair tt tt)))]
	  (R p q))).
lemma (conjunction_3_1_6) (and P Q) L :- (mem P L), (mem Q L).

pf_conjunction_3_1_7_i R :-
	(pi p q\
	 (thm [(and p q)] p
	  [(eq p tt),
	   (eq (opair p q) (opair tt tt)),
	   (eq (and p q) (eq (opair p q) (opair tt tt)))]
	 (R p q))).
lemma (conjunction_3_1_7_i) P L :- (mem (and P _) L).

pf_conjunction_3_1_7_ii R :-
	(pi p q\
	 (thm [(and p q)] q
	  [(eq q tt),
	   (eq (opair p q) (opair tt tt)),
	   (eq (and p q) (eq (opair p q) (opair tt tt)))]
	 (R p q))).
lemma (conjunction_3_1_7_ii) Q L :- (mem (and _ Q) L).


%% 3.2 - Implication
pf_implication_3_2_3_ii R :-
	(pi p q\
	 (thm [p, (imp p q)] q
	  [(and p q),
	   (eq (and p q) tt),
	   (eq (and p q) p),
	   (equiv (and p q) p),
	   (eq p tt),
	   (eq (equiv (and p q) p) (eq (and p q) p)),
	   (eq (imp p q) (equiv (and p q) p))]
	  (R p q))).
lemma (implication_3_2_3_ii) Q L :- (mem (imp P Q) L),
									(mem P L).

% 3.4 - Universal quantification
pf_univ_3_4_1 R :-
	(pi a p q\
	 (thm [(forall a (x\ (eq (p x) (q x))))] (eq (compr a p) (compr a q))
	  [(let x\ [(eq (in x (compr a p)) (in x (compr a q))),
	   			(eq (in x (compr a p)) (q x)),
	   			(eq (p x) (q x)),
	   			(eq (q x) (in x (compr a q))),
	   			(eq (p x) (in x (compr a p))),
	   			(eq (in x (compr a q)) (q x)),
	   			(eq (in x (compr a p)) (p x))])]
	  (R a p q))).
lemma (univ_3_4_1) (eq (compr A P) (compr A Q)) L :-
 	(mem (forall A (x\ (eq (P x) (Q x)))) L).

pf_univ_comm R :-
	(pi a b p\
	 (thm [(forall a (x\ (forall b (y\ (p x y)))))]
	  (forall b (y\ (forall a (x\ (p x y)))))
	  []
	  (R a b p))).

pf_negation_3_5_1 R :-
	(pi p\
	 (thm [ff] p
	  [(forall omega (x\ x)),
	   (eq ff (forall omega (x\ x)))]
	 (R p))).
lemma (negation_3_5_1) P L :- (mem ff L).

pf_conjunction_1 R :-
	(pi p q r\
	 (thm [(imp p r)] (imp (and p q) r)
	  [(suppose (and p q)
		[r,p])]
	  (R p q r))).
%% lemma (conjunction_1) (imp (and P Q) R) L :- (mem (imp P R) L).

pf_conjunction_2 R :-
	(pi p q r\
	 (thm [(imp q r)] (imp (and p q) r)
	  [(suppose (and p q)
		[r,q])]
	  (R p q r))).
%% lemma (conjunction_2) (imp (and P Q) R) L :- (mem (imp Q R) L).

% 3.6 - Disjunction
pf_disjunction_3_6_2_i R :-
	(pi p q\
	 (thm [p] (or p q)
	  [(forall omega (r\ (imp (and (imp p r) (imp q r)) r))),
	   (let r\
	  	[(suppose (and (imp p r) (imp q r))
	  	  [r,(imp p r)])
	  	]),
	   (equiv (or p q) (forall omega (r\ (imp (and (imp p r) (imp q r)) r)))),
	   (eq (or p q) (forall omega (r\ (imp (and (imp p r) (imp q r)) r))))]
	  (R p q))).
lemma (disjunction_3_6_2_i) (or P _) L :- (mem P L).

pf_disjunction_3_6_2_ii R :-
	(pi p q\
	 (thm [q] (or p q)
	  [(forall omega (r\ (imp (and (imp p r) (imp q r)) r))),
	   (let r\
	  	[(suppose (and (imp p r) (imp q r))
	  	  [r,(imp q r)])
	  	]),
	   (equiv (or p q) (forall omega (r\ (imp (and (imp p r) (imp q r)) r)))),
	   (eq (or p q) (forall omega (r\ (imp (and (imp p r) (imp q r)) r))))]
	  (R p q))).
lemma (disjunction_3_6_2_ii) (or _ Q) L :- (mem Q L).

%% 3.7 - Existential quantification
pf_existential_3_7_4 R :-
	(pi a p x\
	 (thm [(p x)] (exists a p)
	  [(forall omega (r\ (imp (forall a (x\ (imp (p x) r))) r))),
	   (let r\ [(suppose (forall a (x\ (imp (p x) r)))
				 [r])
			   ]),
	   (equiv (exists a p)
		(forall omega (r\ (imp (forall a (x\ (imp (p x) r))) r)))),
	   (eq (exists a p) (forall omega (r\ (imp (forall a (x\ (imp (p x) r))) r))))]
	  (R p x))).
lemma (existential_3_7_4) (exists A P) L :- (mem (P X) L).


%% Elimination of existentials : ie. description
%% We can only eliminate unique existentials!
%% Otherwise we would fall into classical logic?
%% pf_unique_existential_description R :-
%% 	(pi a p\
%% 	 (thm [(exists_unique a p)] (p (witness p))
%% 	  []
%% 	  (R a p))).


%% Not sure if this holds...
%% pf_existential_comm R :-
%% 	(pi a b p\
%% 	 (thm [(exists a x\ (exists b y\ (p x y)))]
%% 	  (exists b y\ (exists a x\ (p x y)))
%% 	  [(p (witness _) (witness _)),
%% 	   (exists b y\ (p (witness _) y))]
%% 	 (R a b p))).

main :-  regression _,
		 print "Proof: " R.

regression _ :- pf_eq_refl _,
				pf_eq_sym _,
				pf_eq_trans _,
				pf_equiv_eq_equiv _,
				pf_eq_implies_equiv _,
				pf_equiv_implies_eq _,
				pf_equiv_elim1 _,
				pf_equiv_elim2 _,
				pf_conjunction_3_1_1 _,
				pf_conjunction_3_1_2_i _,
				pf_conjunction_3_1_2_ii _,
				pf_conjunction_3_1_4 _,
				pf_conjunction_3_1_5_i _,
				pf_conjunction_3_1_5_ii _,
				pf_conjunction_3_1_6 _,
				pf_conjunction_3_1_7_i _,
				pf_conjunction_3_1_7_ii _,
				pf_implication_3_2_3_ii _,
				pf_univ_3_4_1 _,
				pf_univ_comm _,
				pf_negation_3_5_1 _,
				pf_conjunction_1 _,
				pf_conjunction_2 _,
				pf_disjunction_3_6_2_i _,
				pf_disjunction_3_6_2_ii _,
				pf_existential_3_7_4 _.
