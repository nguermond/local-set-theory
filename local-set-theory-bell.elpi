%% local set theory following Bell's book, where
%% 'eq' and 'star' are primitive,
%% but without 'forall', and 'imp'.

mem X XS :- std.mem XS X.

%% type remove1 A -> list A -> list A -> prop.
%% remove1 X [X|L] L.
%% remove1 X [Y|L1] [Y|L2] :- not (X = Y), (remove1 X L1 L2).
%% remove1 _ [] _ :- std.fatal-error "remove1 run out of list items".

%% type remove A -> list A -> list A -> prop.
%% remove X [X|L1] L2 :- remove X L1 L2.
%% remove X [Y|L1] [Y|L2] :- not (X = Y), (remove X L1 L2).
%% remove _ [] [].

type sublist list A -> list A -> prop.
sublist [] _.
sublist [X|L1] L2 :- (mem X L2), (sublist L1 L2).


kind tm type.
kind ty type.

type unit ty.
type omega ty.
type prod ty -> ty -> ty.
type power ty -> ty.

type star tm.
type compr ty -> (tm -> tm) -> tm.
type opair tm -> tm -> tm.
type proj1 tm -> tm.
type proj2 tm -> tm.
type eq tm -> tm -> tm.
type in tm -> tm -> tm.


type typeof tm -> ty -> prop.


typeof T A :- (var T), (declare_constraint (typeof T A) [T]).
typeof star unit.
typeof (compr A T) (power A) :- (pi x\ (typeof x A) => (typeof (T x) omega)).
typeof (opair S T) (prod A B) :- (typeof S A), (typeof T B).
typeof (proj1 U) A :- (typeof U (prod A _)).
typeof (proj2 U) B :- (typeof U (prod _ B)).
typeof (eq S T) omega :- (typeof S A), (typeof T A).
typeof (in S T) omega :- (typeof T (power A)), (typeof S A).

kind pf type.
type proof pf -> tm -> (list tm) -> prop.
type thm (list tm) -> tm -> (list tm) -> (list pf) -> prop.


% thm (hyps) (statement) (hilbert proof) (proof tree)
thm H P [] [R0] :- print "—————————————————————————————————————————————————————————————————————————————————————",
				   print "***Proving:***" P,
%				   print "From" H,
				   (!,(proof R0 P H); print "***Failure:***" P H, fail),
				   print "***Success:***" P " [by] " R0.

thm H P [Q|L] [R0|R] :- (thm H Q L R),!,
						print "***Proving:***" P,
						(std.append [Q|L] H L1),
%						print "From" L1,
						(!,(proof R0 P L1); print "***Failure:***" P L1, fail),
						print "***Success:***" P " [by] " R0.


subst T X TX :- (pi x\ (copy_tm x X) => (copy_tm (T x) TX)).

copy_tm X X.
copy_tm (proj1 U1) (proj1 U2) :- (copy_tm U1 U2).
copy_tm (proj2 U1) (proj2 U2) :- (copy_tm U1 U2).
copy_tm (opair S1 T1) (opair S2 T2) :- (copy_tm S1 S2), (copy_tm T1 T2).
copy_tm (eq S1 T1) (eq S2 T2) :- (copy_tm S1 S2), (copy_tm T1 T2).
copy_tm (in S1 T1) (in S2 T2) :- (copy_tm S1 S2), (copy_tm T1 T2).
copy_tm (compr A1 P1) (compr A2 P2) :- (copy_ty A1 A2),
									   (pi x\ (copy_tm (P1 x) (P2 x))).

copy_ty (prod A1 B1) (prod A2 B2) :- (copy_ty A1 A2), (copy_ty B1 B2).
copy_ty (power A1) (power A2) :- (copy_ty A1 A2).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%          Axioms
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

vproof R P L :- print "Attempting to prove:" P "from" L,
				proof R P L.


%% tautology
proof (tautology) P L :- (mem P L). %, print "tautology" P.

%% unity
proof (unity) (eq X star) _ :- %print "unity" X,
							   (typeof X unit).

%% equality
proof (equality S T) PT L :- (mem (eq S T) L),
							 (mem PS L),
							 subst P T PT,
		%					 print "trying equality " S "==" T "," PS "|-" PT,
							 % WARNING: This may run forever
							 % if no solution exists!
							 (P S = PS).
%							 print "equality " S "==" T "," PS "⊢" PT.


%% product beta 1
proof (prod_beta1 S) (eq (proj1 (opair S _)) S) _ :- print "beta1" S.


%% product beta 2
proof (prod_beta2 T) (eq (proj2 (opair _ T)) T) _ :- print "beta2" T.

%% product eta
proof (prod_eta U) (eq (opair (proj1 U) (proj2 U)) U) _ :- print "eta" U,
														   typeof U (prod _ _).


%% comprehension
proof (comprehension (compr A P)) (eq (in T (compr A P)) PT) _ :-
	(P T = PT).
%	print "comprehension" (in T (compr A P)).

%% Extensionality
proof (extensionality R) (eq S T) L :-
	(pi x\ (proof R (equiv (in x S) (in x T)) L)).
%	print "extensionality" S T.

%% This should be a theorem, now that implication is primitive!?
%% %% Equivalence
proof (equivalence R1 R2) (equiv P Q) L :-
	(proof R1 Q [P|L]),
	(proof R2 P [Q|L]).
%	print "equivalence" P Q.

%% Forall
%% This invalid example illustrates why we must
%% sometimes backtrack after eliminating universals
%%  (P X) |- P x
%% -------------------------- (forall-intro)  >> Not possible, since x is free in X!
%%  (P X) |- (forall x, P x)
%% ------------------------------------ (forall-elim)
%%  (forall x, P x) |- (forall x, P x)

%% Whereas the following is valid
%%  P X |- P x
%% ------------------------ (forall-elim)
%%  (forall x, P x) |- P x
%% ------------------------------------ (forall-intro)
%%  (forall x, P x) |- (forall x, P x)
%% because here x is not free in (forall x, P x)!

%% For this reason we place the introduction rules before the elimination rules.

proof (forall-intro R) (forall A P) L :- %print "forall-intro" P,
										 (pi x\ print "Subgoal:" (P x),
										  (proof (R x) (P x) L)).

proof (let-intro R) (let x\ [(Q x)|(L1 x)]) L2 :- %print "let-intro" L2,
												  (pi x\ (thm L2 (Q x) (L1 x) (R x))).


% generalized forall
proof (forall-elim R) PT L :- (mem (forall A P) L),
							  (sigma x\
							   (not (mem (P x) L);
								(P x = forall A P))),
							  %(print "forall-elim >>" (P X) "|-" PT),
							  (proof R PT [(P X)|L]).

proof (let-elim R) PT L :- (mem (let L1) L),
						   (sigma x\
							(not (sublist (L1 x) L))),
						   %(print "let-elim >>" (L1 X) "|-" PT),
						   (std.append (L1 X) L L2),
						   (proof R PT L2).


% implication
proof (suppose-intro R) (suppose P [Q|L1]) L2 :- %print "suppose-intro",
												 (thm [P|L2] Q L1 R).

proof (imp-intro) (imp P Q) L :- (mem (suppose P L1) L),
								 (mem Q L1).
								 %print "imp-intro".

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%    Extra definitions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
type equiv tm -> tm -> tm.
type tt tm.
type and tm -> tm -> tm.
type imp tm -> tm -> tm.
type forall ty -> (tm -> tm) -> tm.
type ff tm.
type neg tm -> tm.
type or tm -> tm -> tm.
type exists ty -> (tm -> tm) -> tm.

typeof (equiv P Q) omega :- (typeof P omega), (typeof Q omega).
typeof tt omega.
typeof (and P Q) omega :- (typeof P omega), (typeof Q omega).
typeof (imp P Q) omega :- (typeof P omega), (typeof Q omega).
typeof (forall A P) omega :- (pi x\ (typeof x A) => (typeof (P x) omega)).
typeof ff omega.
typeof (exists A P) omega :- (pi x\ (typeof x A) => (typeof (P x) omega)).
typeof (neg P) omega :- (typeof P omega).
typeof (or P Q) omega :- (typeof P omega), (typeof Q omega).

proof (equiv-def) (eq (equiv P Q) (eq P Q)) _.
proof (tt-def) (eq tt (eq star star)) _.
proof (and-def) (eq (and P Q) (eq (opair P Q) (opair tt tt))) _.
proof (imp-def) (eq (imp P Q) (equiv (and P Q) P)) _.
proof (forall-def) (eq (forall A P) (eq (compr A P) (compr A (_\ tt)))) _.
proof (ff-def) (eq ff (forall omega (x\ x))) _.
proof (neg-def) (eq (neg P) (imp P ff)) _.
proof (or-def) (eq (or P Q) (forall omega (r\ (imp (and (imp P r) (imp Q r)) r)))) _.
proof (exists-def) (eq (exists A P)
					(forall omega (r\ (imp (forall A (x\ (imp (P x) r))) r)))) _.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   More definitions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

typeof (exists-unique A P) omega :- (pi x\ (typeof x A) => (typeof (P x) omega)).

proof (exists-unique-def) (eq (exists-unique A P)
						   (and (exists A P)
							(forall A x\
							 (forall A y\
							  (imp (and (P x) (P y))
							   (eq x y)))))) _.


%% type (fun S T) (power (power (prod A B))) :-
%% 	(typeof S (power A)), (typeof T (power B)).

%% proof (fun-def) (eq (fun S T)
%% 				 (compr (power (prod A B)) u\
%% 				  (forall A x\ (imp (in x S)
%% 								(existsU B y\ (and (in y T)
%% 											   (in (opair x y) u))))))).

%% proof (lam-def) (eq (lam F)
%% 				 (...)).

%% proof (app-def) (eq (app S T)
%% 				 (...)).

%% evaluate (lam S) NS :- (evaluate S NS).

%% evaluate (app S T) R :- (evaluate S NS),
%% 						(evaluate T NT),
%% 						(subst NS NT R).


%% proof (beta) (eq (app (lam S) T) ST) :- (subst S T ST).

%% proof (reduce) S _ :- (evaluate S T),
%% 					  (proof R T).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%       Theorems
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Only state a lemma is its proof is validated.
% If a theorem is of the form
%   Hyps |- Conc,
% the corresponding lemma should be of the form
%   lemma Name Conc Context :- sublist Hyps Context
proof Name Statement Context :- lemma Name Statement Context.


pf_eq_refl R :- (pi x\ (thm [] (eq x x)
						[(eq (proj1 (opair x x)) x)]
						(R x))).
lemma (eq_refl) (eq X X) _.

pf_eq_sym R :- (pi x y\ (thm [(eq x y)] (eq y x)
						 [(eq x x)]
						 (R x y))).
lemma (eq_sym) (eq X Y) L :- (mem (eq Y X) L).

pf_eq_trans R :-
	(pi x y z\ (thm [(eq x y), (eq y z)] (eq x z)
				[]
				(R x y z))).
lemma (eq_trans) (eq X Z) L :- (mem (eq X Y) L), (mem (eq Y Z) L).

%% Can we prove
%% pf_equiv_def R :-
%% 	(pi p q\
%% 	 (thm [] (eq (imp p q) (eq (and p q) p))
%% 	  [(imp (eq (and p q) p) (imp p q))]
%% 	  (R p q))).

%% pf_equiv_intro R :-
%% 	(pi p q\
%% 	 (thm [(imp p q), (imp q p)] (equiv p q)
%% 	  [(eq (equiv p q) (eq p q))]
%% 	  (R p q))).


pf_equiv_eq_equiv R :-
	(pi p q\
	 (thm [] (equiv (equiv p q) (eq p q))
	  [(eq (eq p q) (equiv p q)),
	   (eq (equiv p q) (eq p q))]
	  (R p q))).
lemma (equiv_eq_equiv) (equiv (equiv P Q) (eq P Q)) _.

pf_eq_implies_equiv R :-
	(pi p q\
	 (thm [(equiv p q)] (eq p q)
	  [(eq (equiv p q) (eq p q))]
	  (R p q))).
lemma (eq_implies_equiv) (eq P Q) L :- (mem (equiv P Q) L).

pf_equiv_implies_eq R :-
	(pi p q\
	 (thm [(eq p q)] (equiv p q)
	  [(eq (eq p q) (equiv p q)),
	   (eq (equiv p q) (eq p q))]
	  (R p q))).
lemma (equiv_implies_eq) (equiv P Q) L :- (mem (eq P Q) L).

pf_equiv_elim1 R :-
	(pi p q\
	 (thm [(equiv p q), p] q
	  [(eq p q)]
	  (R p q))).
lemma (equiv_elim1) Q L :- (mem (equiv P Q) L), (mem P L).

pf_equiv_elim2 R :-
	(pi p q\
	 (thm [(equiv p q), q] p
	  [(eq q p), (eq p q)]
	  (R p q))).
lemma (equiv_elim2) P L :- (mem (equiv P Q) L), (mem Q L).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Theorems from Bell
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 3.1 - Conjunction
pf_conjunction_3_1_1 R :-
	(pi x1 x2 y1 y2\
	 (thm [(eq x1 x2), (eq y1 y2)] (eq (opair x1 y1) (opair x2 y2))
	  [(eq (opair x1 y1) (opair x2 y1)),
	   (eq (opair x1 y1) (opair x1 y1))]
	  (R x1 x2 y1 y2))).
lemma (conjunction_3_1_1) (eq (opair X1 Y1) (opair X2 Y2)) L :-
	(mem (eq X1 X2) L), (mem (eq Y1 Y2) L).

pf_conjunction_3_1_2_i R :-
	(pi x1 x2 y1 y2\
	 (thm [(eq (opair x1 y1) (opair x2 y2))] (eq x1 x2)
	  [(eq (proj1 (opair x2 y2)) x2),
	   (eq x1 (proj1 (opair x2 y2))),
	   (eq (proj1 (opair x1 y1)) x1),
	   (eq (proj1 (opair x1 y1)) (proj1 (opair x2 y2))),
	   (eq (proj1 (opair x1 y1)) (proj1 (opair x1 y1)))]
	  (R x1 x2 y1 y2))).
lemma (conjunction_3_1_2_i) (eq X1 X2) L :-
	(mem (eq (opair X1 Y1) (opair X2 Y2)) L).

pf_conjunction_3_1_2_ii R :-
	(pi x1 x2 y1 y2\
	 (thm [(eq (opair x1 y1) (opair x2 y2))] (eq y1 y2)
	  [(eq (proj2 (opair x2 y2)) y2),
	   (eq y1 (proj2 (opair x2 y2))),
	   (eq (proj2 (opair x1 y1)) y1),
	   (eq (proj2 (opair x1 y1)) (proj2 (opair x2 y2))),
	   (eq (proj2 (opair x1 y1)) (proj2 (opair x1 y1)))]
	  (R x1 x2 y1 y2))).
lemma (conjunction_3_1_2_i) (eq Y1 Y2) L :-
	(mem (eq (opair X1 Y1) (opair X2 Y2)) L).

pf_conjunction_3_1_4 R :-
	(thm [] tt
	 [(eq (eq star star) tt),
	  (eq star star),
	  (eq tt (eq star star))]
	 R).
lemma (conjunction_3_1_4) tt _.

pf_conjunction_3_1_5_i R :-
	(pi p\
	 (thm [p] (eq p tt)
	  [(eq (equiv p tt) (eq p tt)),
	   (equiv p tt),
	   tt]
	  (R p))).
lemma (conjunction_3_1_5_i) (eq P tt) L :- (mem P L).

pf_conjunction_3_1_5_ii R :-
	(pi p\
	 (thm [(eq p tt)] p
	  [(eq tt p), tt]
	  (R p))).
lemma (conjunction_3_1_5_ii) P L :- (mem (eq P tt) L).

pf_conjunction_3_1_6 R :-
	(pi p q\
	 (thm [p, q] (and p q)
	  [(eq (opair p q) (opair tt tt)),
	   (eq p tt),
	   (eq q tt),
	   (eq (eq (opair p q) (opair tt tt)) (and p q)),
	   (eq (and p q) (eq (opair p q) (opair tt tt)))]
	  (R p q))).
lemma (conjunction_3_1_6) (and P Q) L :- (mem P L), (mem Q L).

pf_conjunction_3_1_7_i R :-
	(pi p q\
	 (thm [(and p q)] p
	  [(eq p tt),
	   (eq (opair p q) (opair tt tt)),
	   (eq (and p q) (eq (opair p q) (opair tt tt)))]
	 (R p q))).
lemma (conjunction_3_1_7_i) P L :- (mem (and P _) L).

pf_conjunction_3_1_7_ii R :-
	(pi p q\
	 (thm [(and p q)] q
	  [(eq q tt),
	   (eq (opair p q) (opair tt tt)),
	   (eq (and p q) (eq (opair p q) (opair tt tt)))]
	 (R p q))).
lemma (conjunction_3_1_7_ii) Q L :- (mem (and _ Q) L).


%% 3.2 - Implication
pf_implication_3_2_3_ii R :-
	(pi p q\
	 (thm [p, (imp p q)] q
	  [(and p q),
	   (eq (and p q) tt),
	   (eq (and p q) p),
	   (equiv (and p q) p),
	   (eq p tt),
	   (eq (equiv (and p q) p) (eq (and p q) p)),
	   (eq (imp p q) (equiv (and p q) p))]
	  (R p q))).
lemma (implication_3_2_3_ii) Q L :- (mem (imp P Q) L),
									(mem P L).

% 3.4 - Universal quantification
pf_univ_3_4_1 R :-
	(pi a p q\
	 (thm [(forall a (x\ (eq (p x) (q x))))] (eq (compr a p) (compr a q))
	  [(let x\ [(eq (in x (compr a p)) (in x (compr a q))),
	   			(eq (in x (compr a p)) (q x)),
	   			(eq (p x) (q x)),
	   			(eq (q x) (in x (compr a q))),
	   			(eq (p x) (in x (compr a p))),
	   			(eq (in x (compr a q)) (q x)),
	   			(eq (in x (compr a p)) (p x))])]
	  (R a p q))).
lemma (univ_3_4_1) (eq (compr A P) (compr A Q)) L :-
 	(mem (forall A (x\ (eq (P x) (Q x)))) L).

pf_univ_comm R :-
	(pi a b p\
	 (thm [(forall a (x\ (forall b (y\ (p x y)))))]
	  (forall b (y\ (forall a (x\ (p x y)))))
	  []
	  (R a b p))).

pf_negation_3_5_1 R :-
	(pi p\
	 (thm [ff] p
	  [(forall omega (x\ x)),
	   (eq ff (forall omega (x\ x)))]
	 (R p))).
lemma (negation_3_5_1) P L :- (mem ff L).

pf_conjunction_1 R :-
	(pi p q r\
	 (thm [(imp p r)] (imp (and p q) r)
	  [(suppose (and p q)
		[r,p])]
	  (R p q r))).
%% lemma (conjunction_1) (imp (and P Q) R) L :- (mem (imp P R) L).

pf_conjunction_2 R :-
	(pi p q r\
	 (thm [(imp q r)] (imp (and p q) r)
	  [(suppose (and p q)
		[r,q])]
	  (R p q r))).
%% lemma (conjunction_2) (imp (and P Q) R) L :- (mem (imp Q R) L).

% 3.6 - Disjunction
pf_disjunction_3_6_2_i R :-
	(pi p q\
	 (thm [p] (or p q)
	  [(forall omega (r\ (imp (and (imp p r) (imp q r)) r))),
	   (let r\
	  	[(suppose (and (imp p r) (imp q r))
	  	  [r,(imp p r)])
	  	]),
	   (equiv (or p q) (forall omega (r\ (imp (and (imp p r) (imp q r)) r)))),
	   (eq (or p q) (forall omega (r\ (imp (and (imp p r) (imp q r)) r))))]
	  (R p q))).
lemma (disjunction_3_6_2_i) (or P _) L :- (mem P L).

pf_disjunction_3_6_2_ii R :-
	(pi p q\
	 (thm [q] (or p q)
	  [(forall omega (r\ (imp (and (imp p r) (imp q r)) r))),
	   (let r\
	  	[(suppose (and (imp p r) (imp q r))
	  	  [r,(imp q r)])
	  	]),
	   (equiv (or p q) (forall omega (r\ (imp (and (imp p r) (imp q r)) r)))),
	   (eq (or p q) (forall omega (r\ (imp (and (imp p r) (imp q r)) r))))]
	  (R p q))).
lemma (disjunction_3_6_2_ii) (or _ Q) L :- (mem Q L).

%% 3.7 - Existential quantification
pf_existential_3_7_4 R :-
	(pi a p x\
	 (thm [(p x)] (exists a p)
	  [(forall omega (r\ (imp (forall a (x\ (imp (p x) r))) r))),
	   (let r\ [(suppose (forall a (x\ (imp (p x) r)))
				 [r])
			   ]),
	   (equiv (exists a p)
		(forall omega (r\ (imp (forall a (x\ (imp (p x) r))) r)))),
	   (eq (exists a p) (forall omega (r\ (imp (forall a (x\ (imp (p x) r))) r))))]
	  (R p x))).
lemma (existential_3_7_4) (exists A P) L :- (mem (P X) L).


%% Elimination of existentials : ie. description
%% We can only eliminate unique existentials of power type!
%% Whether an existential can be eliminated depends on the
%% actual type! For example, the following eliminate:
%% (exists unit P) |- (P star)
%% (exists (prod A B) P) |- (exists A x\ (exists B y\ (P opair x y)))
%% (existsU (power A) P) |- (P (compr A x\
%%                            (exists (power A) u\ (and (in x u) (P u)))))
%% (existsU omega P) |- (P (P tt))

%% (eq (existsU A P)
%%  (and (exists A P)
%%   (forall A x\
%%    (forall A y\
%% 	(imp (and (P x) (P y))
%% 	 (eq x y))))))

type tt tm.
type epsilon ty -> (tm -> tm) -> tm.
type epsilon-def ty -> (tm -> tm) -> pf.

proof (epsilon-def omega P) (eq (epsilon omega P) (P tt)) _.


pf_comprehension_lemma_1 R :-
	(pi a x p\
	 (thm [(in x (compr a p))] (p x)
	  [(eq (in x (compr a p)) (p x))]
	  (R a x p))).
lemma (comprehension_lemma_1) PT L :- (mem (in T (compr A P)) L),
									  (PT = P T).

pf_comprehension_lemma_2 R :-
	(pi a x p\
	 (thm [(p x)] (in x (compr a p))
	  [(eq (p x) (in x (compr a p))),
	   (eq (in x (compr a p)) (p x))]
	  (R a x p))).
lemma (comprehension_lemma_2) (in T (compr _ P)) L :- (mem (P T) L).

pf_extensionality_converse R :-
	(pi a x p q\
	 (thm [(eq (compr a p) (compr a q))]
	  (eq (p x) (q x))
	  [(equiv (p x) (q x)),
	   (imp (p x) (q x)),
	   (imp (q x) (p x)),
	   (suppose (p x)
	   	[(q x),
	   	 (in x (compr a q)),
	   	 (in x (compr a p))
	   	]),
	   (suppose (q x)
	   	[(p x),
	   	 (in x (compr a p)),
	   	 (in x (compr a q))
	   	]),
	   (eq (compr a q) (compr a p))
	  ]
	  (R a p q))).
lemma (extensionality_converse) (eq PX QX) L :-
	(mem (eq (compr A P) (compr A Q)) L), (PX = P X), (QX = Q X).


pf_description_lemma1 R :-
	(pi p\
	 (thm [] (equiv p (eq (compr unit (x\ p)) (compr unit (x\ tt))))
	  [(imp (eq (compr unit (x\ p)) (compr unit (x\ tt))) p),
	   (suppose (eq (compr unit (x\ p)) (compr unit (x\ tt)))
	   	[p, (eq p tt)]),
	   (imp p (eq (compr unit (x\ p)) (compr unit (x\ tt)))),
	   (suppose p
		[(eq (compr unit (x\ p)) (compr unit (x\ tt))),
		 (let x\
		  [(eq (in x (compr unit (x\ p))) (in x (compr unit (x\ tt)))),
		   (eq (in x (compr unit (x\ p))) tt)
		  ]),
		 (eq p tt),
		]),
	   (let x\
		[(eq p (in x (compr unit (x\ p)))),
		 (eq (in x (compr unit (x\ p))) p),
		 (eq tt (in x (compr unit (x\ tt)))),
		 (eq (in x (compr unit (x\ tt))) tt)
		])
	  ]
	  (R p))).



%% pf_description_3_8 R :-
%% 	(pi a p\
%% 	 (thm [(exists-unique a p)]
%% 	  (p (epsilon omega p))
%% 	  [(p (p tt)),
%% 	   (forall omega x\
%% 	   	(forall omega y\ (imp (and (p x) (p y)) (eq x y)))),
%% 	   (exists omega p),
%% 	   (and (exists omega p) (forall omega x\
%% 	   						  (forall omega y\ (imp (and (p x) (p y)) (eq x y))))),
%% 	   (
%% 	   (eq (epsilon omega p) (p tt)),
%% 	   (eq (exists-unique omega p) (and (exists omega p) (forall omega x\
%% 	   		(forall omega y\ (imp (and (p x) (p y)) (eq x y))))))]
%% 	  (R a p))).


%% Not sure if this holds...
%% pf_existential_comm R :-
%% 	(pi a b p\
%% 	 (thm [(exists a x\ (exists b y\ (p x y)))]
%% 	  (exists b y\ (exists a x\ (p x y)))
%% 	  [(p (witness _) (witness _)),
%% 	   (exists b y\ (p (witness _) y))]
%% 	 (R a b p))).

main :-  pf_description_3_8 R,
		 print "Proof: " R.

regression _ :- pf_eq_refl _,
				pf_eq_sym _,
				pf_eq_trans _,
				pf_equiv_eq_equiv _,
				pf_eq_implies_equiv _,
				pf_equiv_implies_eq _,
				pf_equiv_elim1 _,
				pf_equiv_elim2 _,
				pf_conjunction_3_1_1 _,
				pf_conjunction_3_1_2_i _,
				pf_conjunction_3_1_2_ii _,
				pf_conjunction_3_1_4 _,
				pf_conjunction_3_1_5_i _,
				pf_conjunction_3_1_5_ii _,
				pf_conjunction_3_1_6 _,
				pf_conjunction_3_1_7_i _,
				pf_conjunction_3_1_7_ii _,
				pf_implication_3_2_3_ii _,
				pf_univ_3_4_1 _,
				pf_univ_comm _,
				pf_negation_3_5_1 _,
				pf_conjunction_1 _,
				pf_conjunction_2 _,
				pf_disjunction_3_6_2_i _,
				pf_disjunction_3_6_2_ii _,
				pf_existential_3_7_4 _,
				pf_comprehension_lemma_1 _,
				pf_comprehension_lemma_2 _,
				pf_extensionality_converse _,
				pf_description_lemma1 _.
