%% local set theory following Bell's book, where
%% 'eq' and 'star' are primitive,
%% but without 'forall', and 'imp'.

mem X XS :- std.mem XS X.

type sublist list A -> list A -> prop.
sublist [] _.
sublist [X|L1] L2 :- (mem X L2), (sublist L1 L2).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

kind tm type.
kind ty type.

type unit ty.
type omega ty.
type prod ty -> ty -> ty.
type power ty -> ty.

type star tm.
type compr ty -> (tm -> tm) -> tm.
type opair tm -> tm -> tm.
type proj1 tm -> tm.
type proj2 tm -> tm.
type eq tm -> tm -> tm.
type in tm -> tm -> tm.


type typeof tm -> ty -> prop.


typeof T A :- (var T), (declare_constraint (typeof T A) [T]).
typeof star unit.
typeof (compr A T) (power A) :- (pi x\ (typeof x A) => (typeof (T x) omega)).
typeof (opair S T) (prod A B) :- (typeof S A), (typeof T B).
typeof (proj1 U) A :- (typeof U (prod A _)).
typeof (proj2 U) B :- (typeof U (prod _ B)).
typeof (eq S T) omega :- (typeof S A), (typeof T A).
typeof (in S T) omega :- (typeof T (power A)), (typeof S A).

kind pf type.
type proof pf -> tm -> (list tm) -> prop.
type thm (list tm) -> tm -> (list tm) -> (list pf) -> prop.


% thm (hyps) (statement) (hilbert proof) (proof tree)
thm H P [] [R0] :- print "—————————————————————————————————————————————————————————————————————————————————————",
				   print "***Proving:***" P,
%				   print "From" H,
				   (!,(proof R0 P H); print "***Failure:***" P H, fail),
				   print "***Success:***" P " [by] " R0.

thm H P [Q|L] [R0|R] :- (thm H Q L R),!,
						print "***Proving:***" P,
						(std.append [Q|L] H L1),
%						print "From" L1,
						(!,(proof R0 P L1); print "***Failure:***" P L1, fail),
						print "***Success:***" P " [by] " R0.


subst T X TX :- (pi x\ (copy_tm x X) => (copy_tm (T x) TX)).

copy_tm X X.
copy_tm (proj1 U1) (proj1 U2) :- (copy_tm U1 U2).
copy_tm (proj2 U1) (proj2 U2) :- (copy_tm U1 U2).
copy_tm (opair S1 T1) (opair S2 T2) :- (copy_tm S1 S2), (copy_tm T1 T2).
copy_tm (eq S1 T1) (eq S2 T2) :- (copy_tm S1 S2), (copy_tm T1 T2).
copy_tm (in S1 T1) (in S2 T2) :- (copy_tm S1 S2), (copy_tm T1 T2).
copy_tm (compr A1 P1) (compr A2 P2) :- (copy_ty A1 A2),
									   (pi x\ (copy_tm (P1 x) (P2 x))).
%% copy_tm (exists A1 P1) (exists A2 P2) :- (copy_ty A1 A2),
%% 										 (pi x\ (copy_tm (P1 x) (P2 x))).
%% copy_tm (and S1 T1) (and S2 T2) :- (copy_tm S1 S2), (copy_tm T1 T2).

copy_ty A A.
copy_ty (prod A1 B1) (prod A2 B2) :- (copy_ty A1 A2), (copy_ty B1 B2).
copy_ty (power A1) (power A2) :- (copy_ty A1 A2).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%          Axioms
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% tautology
proof (tautology) P L :- (mem P L).

%% unity
proof (unity) (eq X star) _ :- (typeof X unit).

%% equality
proof (equality S T) PT L :- (mem (eq S T) L),
							 %print "trying equality " S "∼" T "," PS "⊢" PT,
							 ((subst P T PT, mem (P S) L);
							  (mem PS L , subst P S PS)).
							 %print ">> found " P.
							 % WARNING: This may run forever
							 % if no solution exists!
							 %print "equality " S "∼" T "," PS "⊢" PT.


%% product beta 1
proof (prod_beta1 S) (eq (proj1 (opair S _)) S) _.


%% product beta 2
proof (prod_beta2 T) (eq (proj2 (opair _ T)) T) _.

%% product eta
proof (prod_eta U) (eq (opair (proj1 U) (proj2 U)) U) _ :- typeof U (prod _ _).


%% comprehension
proof (comprehension (compr A P)) (eq (in T (compr A P)) PT) _ :- (P T = PT).

%% Extensionality
%% !!!!!!!!!!!!!!!! Should not mention equiv !!!!!!!!!!!!
proof (extensionality R) (eq S T) L :-
	%% (pi x\ (proof R (equiv (in x S) (in x T)) L))
	(pi x\ (proof R (equiv (in x S) (in x T)) L)).



%% Equivalence (propositional extensionality)
proof (equivalence R1 R2) (equiv P Q) L :-
	(proof R1 Q [P|L]),
	(proof R2 P [Q|L]).

%% Forall
%% This invalid example illustrates why we must
%% sometimes backtrack after eliminating universals
%%  (P X) |- P x
%% -------------------------- (forall-intro)  >> Not possible, since x is free in X!
%%  (P X) |- (forall x, P x)
%% ------------------------------------ (forall-elim)
%%  (forall x, P x) |- (forall x, P x)

%% Whereas the following is valid
%%  P X |- P x
%% ------------------------ (forall-elim)
%%  (forall x, P x) |- P x
%% ------------------------------------ (forall-intro)
%%  (forall x, P x) |- (forall x, P x)
%% because here x is not free in (forall x, P x)!

%% For this reason we place the introduction rules before the elimination rules.
proof (forall-intro R) (forall A P) L :- %print "forall-intro" P,
										 !,(pi x\ print "Subgoal:" (P x),
										  (proof (R x) (P x) L)).

proof (let-intro R) (let x\ [(Q x)|(L1 x)]) L2 :- %print "let-intro" L2,
												  !,(pi x\ (thm L2 (Q x) (L1 x) (R x))).


% generalized forall
proof (forall-elim R) PT L :- (mem (forall A P) L),
							  (sigma x\
							   (not (mem (P x) L);
								(P x = forall A P))),
							  %(print "forall-elim >>" (P X) "|-" PT),
							  (proof R PT [(P X)|L]).

proof (let-elim R) PT L :- (mem (let L1) L),
						   (sigma x\
							(not (sublist (L1 x) L))),
						   %(print "let-elim >>" (L1 X) "|-" PT),
						   (std.append (L1 X) L L2),
						   (proof R PT L2).


% implication
proof (suppose-intro R) (suppose P [Q|L1]) L2 :- !,(thm [P|L2] Q L1 R).

proof (imp-intro) (imp P Q) L :- (mem (suppose P L1) L),
								 (mem Q L1).
